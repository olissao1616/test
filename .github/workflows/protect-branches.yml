name: Protect branches (reusable)

on:
  workflow_call:
    inputs:
      target_repo:
        description: "Full repo name to protect (e.g., bcgov-c/my-repo). Defaults to current repo."
        required: false
        type: string
      licence_plate:
        description: "Licence plate (for correlation/logging)"
        required: false
        type: string
      branches:
        description: "Comma-separated list of branches to protect (e.g., main,test,develop)"
        required: true
        type: string
      required_contexts:
        description: "Comma-separated required status check contexts"
        required: false
        default: "policy-check"
        type: string
permissions:
  contents: write
  repository-projects: write

jobs:
  protect:
    runs-on: ubuntu-latest
    steps:
      - name: Apply branch protections
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BRANCH_PROTECTION_TOKEN || secrets.CI || github.token }}
          script: |
            const targetRepo = ("${{ inputs.target_repo }}" || process.env.GITHUB_REPOSITORY).trim();
            const licencePlate = ("${{ inputs.licence_plate }}" || "").trim();
            const branchesCsv = "${{ inputs.branches }}";
            const contextsCsv = "${{ inputs.required_contexts }}";

            if (!targetRepo.includes('/')) {
              core.setFailed(`Invalid target_repo: ${targetRepo}`);
              return;
            }

            const [owner, repo] = targetRepo.split('/', 2);
            const branches = branchesCsv.split(',').map(s => s.trim()).filter(Boolean);
            const contexts = contextsCsv.split(',').map(s => s.trim()).filter(Boolean);

            if (branches.length === 0) {
              core.setFailed('No branches provided');
              return;
            }

            core.info(`Protecting repo: ${owner}/${repo}`);
            if (licencePlate) core.info(`Licence plate: ${licencePlate}`);
            core.info(`Branches: ${branches.join(', ')}`);
            core.info(`Required contexts: ${contexts.join(', ')}`);

            for (const branch of branches) {
              core.info(`Applying protection to ${branch}...`);
              try {
                await github.rest.repos.updateBranchProtection({
                  owner,
                  repo,
                  branch,
                  required_status_checks: {
                    strict: true,
                    contexts,
                  },
                  enforce_admins: true,
                  required_pull_request_reviews: {
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true,
                    required_approving_review_count: 2,
                  },
                  restrictions: null,
                  required_linear_history: true,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true,
                });
                core.info(`âœ“ Protected ${branch}`);
              } catch (err) {
                const status = err?.status ?? err?.response?.status;
                const message = err?.message || String(err);

                // Common case: workflow is using GITHUB_TOKEN (integration token) which is blocked
                // from updating branch protection in many org/repo configurations.
                if (status === 403 && message.includes('Resource not accessible by integration')) {
                  core.warning(
                    `Skipped protecting ${branch}: ${message}. ` +
                      'Provide an admin-capable token via BRANCH_PROTECTION_TOKEN (or CI) secret to enable branch protection.'
                  );
                  continue;
                }

                core.error(`Failed to protect ${branch}: ${message}`);
                throw err;
              }
            }
